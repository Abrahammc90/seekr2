"""
runner_sda.py

A command-line tool for running SEEKR calculations using the SDA
engine either locally or on a computing resource.
"""
import os
import re
import argparse
import glob

import seekr2.modules.common_base as base
import seekr2.modules.common_sim_sda as sim_sda

REACTION_FILENAME = "p2.rxna"
SDA_INPUT = "sda.in"

def cleanse_bd_outputs(directory, check_mode=True):
    """
    Check for simulation outputs in an existing directory, optionally
    delete them to make way for new outputs. If 'check_mode' is
    False, then files won't be deleted, but their existence will be
    reported.
    
    Parameters
    ----------
    directory : str
        The path to the directory where the BD files will be 'cleansed'.
    
    check_mode : bool, default True
        If set to True, then files will be detected, but not removed.
        If set to False, then files will be both detected and removed.
        
    Returns
    -------
    files_will_be_removed : bool
        If files generated by a BD preparation or simulation were 
        present, will return True, will return False otherwise.
    """
    files_will_be_removed = False
    output_files_glob = os.path.join(directory, base.SDA_OUTPUT)
    output_files_list = glob.glob(output_files_glob)
    for output_file in output_files_list:
        files_will_be_removed = True
        if not check_mode:
            os.remove(output_file)
    
    
    traj_file_glob = os.path.join(directory, "traj*")
    for traj_file in glob.glob(traj_file_glob):
        files_will_be_removed = True
        if not check_mode:
            os.remove(traj_file)
    return files_will_be_removed

def make_pdb_noh(model, rootdir, bd_directory=None):
    
    """
    Creates PDBs of the solutes without hydrogens, needed by SDA
    as it uses an implicit hydrogen model.

    Parameters
    ----------
    model : Model()
        The model object contains all information needed for a SEEKR2
        calculation.

    rootdir : str
        The model's root directory.

    bd_directory : str
        Directory where the PDBs will be written.
    """

    if bd_directory is None:
        # B-surface
        bd_directory = os.path.join(
            rootdir, model.k_on_info.b_surface_directory)
    else:
        # BD Milestone
        bd_directory = os.path.join(rootdir, bd_directory)

    curdir = os.getcwd()
    print("moving to directory:", bd_directory)
    os.chdir(bd_directory)
    print("Creating PDBs without hydrogens")

    for solute in model.sda_settings.solutes:
        pqr_filename = os.path.basename(solute.pqr_filename)
        pqr_lines = open(os.path.join(bd_directory, pqr_filename), "r").readlines()
        solute_name = ".".join(pqr_filename.split(".")[:-1])
        pdb_noh_lines = []
        
        atom_id = 1
        for I in range(len(pqr_lines)):
            line = pqr_lines[I]
            if line.startswith("ATOM") or line.startswith("HETATM"):
                atomname = line[12:16].strip()
                if atomname[0] == "H" or atomname[0].isnumeric():
                    continue
                before_id = line[:6]
                after_id = line[11:]
                new_line = before_id + "{:>5s}".format(str(I+1)) + after_id
                pdb_noh_lines.append(new_line[:54] + "  1.00  0.00   \n")
                atom_id += 1
                #print(atomname)
            else:
                pdb_noh_lines.append(line)
        #exit()
        with open(solute_name + "_noh.pdb", "w") as pdb:
            for line in pdb_noh_lines:
                pdb.write(line)

    os.chdir(curdir)
    return

def make_sda_grids(model, rootdir, sda_bin_dir, sda_auxi_dir=None, bd_directory=None):
    """
    Creates SDA grids and effective charge models.
    
    Parameters
    ----------
    model : Model()
        The model object contains all information needed for a SEEKR2
        calculation.

    rootdir : str
        The model's root directory.
    
    sda_bin_dir : str
        Path to the SDA binary files.

    sda_auxi_dir : str
        Path to the SDA binary files.

    bd_directory : str
        Directory where grids will be created.
        
    """

    if bd_directory is None:
        # B-surface
        bd_directory = os.path.join(
            rootdir, model.k_on_info.b_surface_directory)
    else:
        # BD Milestone
        bd_directory = os.path.join(rootdir, bd_directory)

    curdir = os.getcwd()
    print("moving to directory:", bd_directory)
    assert model.k_on_info.ions is not None, \
            "Ions must be included for grids"
    os.chdir(bd_directory)
    print("creating SDA grids")

    solute_idx = 0
    for solute in model.sda_settings.solutes:

        solute_idx += 1
        pqr_filename = os.path.basename(\
                solute.pqr_filename)
        solute_name = ".".join(pqr_filename.split(".")[:-1])
        pdb_filename = solute_name + "_noh.pdb"


        #Making APBS grids
        apbs_input = sim_sda.APBS_Input()

        ionic_strength = 0
        for model_ion in model.k_on_info.ions:
            bd_ion = sim_sda.Ion()
            bd_ion.radius = model_ion.radius
            bd_ion.charge = model_ion.charge
            bd_ion.conc = model_ion.conc
            apbs_input.solvent.ions.append(bd_ion)
            ionic_strength += model_ion.conc*model_ion.charge**2 / 2

        apbs_input.solute = solute
        apbs_input.temperature = model.temperature

        apbs_input.solute_pqr = pqr_filename
        apbs_input.solute_name = solute_name

        apbs_input.write()

        apbs_input_name = solute_name+"_apbs.in"
        run_apbs_command = "apbs " + apbs_input_name \
            + " > apbs_"+str(solute_idx)+".out"
        os.system(run_apbs_command)
        assert len(glob.glob(apbs_input_name)) > 0, "Problem running " \
        "apbs - APBS UHBD file(s) not found: " + apbs_input_name

        apbs_output_grid = solute_name + "*.grd"
        epf = solute_name + "_ep.grd"
        
        #Converting electrostatic potential energy to kcal
        sda_convert_bin = os.path.join(sda_bin_dir, "convert_grid")
        run_sda_convert_command = sda_convert_bin + " " + apbs_output_grid + \
            " " + epf + " -scale 0.6 -convert > apbs_grid_conversion_" + \
            str(solute_idx) + ".out"
        os.system(run_sda_convert_command)


        #Making SDA grids and effective charges
        sda_grid_inputs = sim_sda.SDA_grid_inputs()

        sda_grid_inputs.epf = epf

        qef = solute_name + ".echa"
        qef_input = solute_name + "_ecm.in"
        tcha = solute_name + ".tcha"
        sda_grid_inputs.echa = qef
        sda_grid_inputs.ecm_input = qef_input
        sda_grid_inputs.tcha = tcha

        edf = solute_name + "_ed.grd"
        edf_input = solute_name + "_ed.in"
        hdf = solute_name + "_hd.grd"
        hdf_input = solute_name + "_hd.in"
        sda_grid_inputs.edf = edf
        sda_grid_inputs.edf_input = edf_input
        sda_grid_inputs.hdf = hdf
        sda_grid_inputs.hdf_input = hdf_input
        if solute.solute_grid.lj_repf is not None:
            lj_repf = solute_name + "_ljrep.grd"
            lj_repf_input = solute_name + "_ljrep.in"
            sda_grid_inputs.lj_repf = lj_repf
            sda_grid_inputs.lj_repf_input = lj_repf_input

        sda_grid_inputs.solute_name = solute_name
        sda_grid_inputs.solute_pdb = pdb_filename
        sda_grid_inputs.temperature = model.temperature
        sda_grid_inputs.ionic_strength = ionic_strength

        sda_grid_inputs.write()

        assert solute.type.lower() in ["protein", "non_protein"], "Solute type " + solute.type.lower() + " not recognized."

        protein_surface_test_charge_command = None
        surface_test_charge_command = None
        test_charge_command = None
        if solute.type.lower() == "non_protein":
            if solute.solute_grid.surface.lower() == "yes":
                surface_test_charge_bin = os.path.join(sda_auxi_dir, \
                                  "Kon-rates-SmallMolecule/Generate-ECMSites-SmallMol/ECM_surface.py")
                
                if os.path.exists(surface_test_charge_bin):
                    protein_surface_test_charge_command = "python " + protein_surface_test_charge_bin + " " + pqr_filename + " -threshold 3" + \
                    " > tcha_" + str(solute_idx) + ".out"
                else:
                    surface_test_charge_bin = os.path.join(sda_auxi_dir, \
                                  "Kon-rates-SmallMolecule/Generate-ECMSites-SmallMol/ECM_ligand.py")

                    surface_test_charge_command = "python " + surface_test_charge_bin + " " + pqr_filename + \
                    " > tcha_" + str(solute_idx) + ".out"
            else:
                test_charge_bin = os.path.join(sda_auxi_dir, \
                                  "Kon-rates-SmallMolecule/Generate-ECMSites-SmallMol/ECM_ligand.py")

                test_charge_command = "python " + test_charge_bin + " " + pqr_filename + \
                " > tcha_" + str(solute_idx) + ".out"
        elif solute.type.lower() == "protein":
            test_charge_bin = os.path.join(sda_bin_dir, \
                                               "ecm_mksites")
            test_charge_command = test_charge_bin + " " + pdb_filename + " " + \
                tcha + " > tcha_" + str(solute_idx) + ".out"
            if solute.solute_grid.surface.lower() == "yes":
                protein_surface_test_charge_bin = os.path.join(sda_auxi_dir, \
                              "Kon-rates-SmallMolecule/Generate-ECMSites-SmallMol/ECM_surface.py")
                if os.path.exists(protein_surface_test_charge_bin):
                    protein_surface_test_charge_command = "python " + protein_surface_test_charge_bin + " " + pqr_filename + " -threshold 3" + \
                    " > tcha_" + str(solute_idx) + ".out"
                else:
                    protein_surface_test_charge_bin = os.path.join(sda_auxi_dir, \
                              "Kon-rates-SmallMolecule/Generate-ECMSites-SmallMol/ECM_surface.py")
                    protein_surface_test_charge_command = "python " + protein_surface_test_charge_bin + " " + pqr_filename + \
                    " > tcha_" + str(solute_idx) + ".out"
            
        
        if test_charge_command != None:
            print("running command", test_charge_command)
            os.system(test_charge_command)
        if surface_test_charge_command != None:
            print("running command", surface_test_charge_command)
            os.system(surface_test_charge_command)
        if protein_surface_test_charge_command != None:
            print("running command", protein_surface_test_charge_command)
            os.system("mv " + tcha + " tmp.tcha")
            os.system(protein_surface_test_charge_command)
            os.system("cat " + pqr_filename.split(".")[0] + ".tcha >> tmp.tcha")
            os.system("mv tmp.tcha " + tcha)


        effective_charge_bin = os.path.join(sda_bin_dir, \
                                            "ecm_expand")
        effective_charge_command = effective_charge_bin + " " + qef_input + \
        " > ecm_" + str(solute_idx) + ".out"
        print("running command", effective_charge_command)
        os.system(effective_charge_command)

        edhdlj_bin = os.path.join(sda_bin_dir, "make_edhdlj_grid")
        if solute.solute_grid.lj_repf is not None:
        #if hasattr(solute_name, 'lj_repf'):
            edhdlj_command = edhdlj_bin + " -ed " + edf_input + " -hd " + hdf_input + \
            " -ljrep " + lj_repf_input + " > edhdlj_" + str(solute_idx) + ".out"
        else:
            edhdlj_command = edhdlj_bin + " -ed " + edf_input + " -hd " + hdf_input + \
            " > edhdlj_" + str(solute_idx) + ".out"
        print("running command", edhdlj_command)
        os.system(edhdlj_command)
        print("")

    os.chdir(curdir)
    return

    #sim_sda.make_and_run_sda_grids()

def make_sda_reaction(model, rootdir, atoms_rec, atoms_lig, 
                      bd_directory=None):
    """
    Creates SDA reaction file.
    
    Parameters
    ----------
    model : Model()
        The model object contains all information needed for a SEEKR2
        calculation.

    rootdir : str
        The model's root directory.
        
    abs_reaction_path : str
        The absolute path to where the reaction file will be written.
        
    atoms_rec : array
        Array of the reactive receptor atoms in PDB format.

    atoms_lig : array
        Array of the reactive ligand atoms in PDB format.
    
    bd_directory : str
        Directory where the reaction criteria file will be written.
    """
    
    print("Creating SDA reaction file")
    print("")

    if bd_directory is None:
        # B-surface
        bd_directory = os.path.join(
            rootdir, model.k_on_info.b_surface_directory)
    else:
        # BD Milestone
        bd_directory = os.path.join(rootdir, bd_directory)

    abs_reaction_path = os.path.join(bd_directory, "p2.rxna")

    sda_reaction = sim_sda.Reaction()
    sda_reaction.atoms_rec = atoms_rec
    sda_reaction.atoms_lig = atoms_lig



    sda_reaction.write(abs_reaction_path)
    return


def make_sda_input(model, rootdir, num_b_surface_trajectories, 
                   bd_directory=None):

    """
    Creates SDA input file with all input parameters set.
    If bd_directory is None, then b_surface is assumed.
    
    Parameters
    ----------
    model : Model()
        The SEEKR2 model.
        
    rootdir : str
        The model's root directory.
    
    num_b_surface_trajectories : int
        Number of BD trajectories.
    
    bd_directory : str
        b_surface directory.
    """
    
    sda_input = sim_sda.Input()
    if bd_directory is None:
        # B-surface
        bd_directory = os.path.join(
            rootdir, model.k_on_info.b_surface_directory)
    else:
        # BD Milestone
        bd_directory = os.path.join(rootdir, bd_directory)
    
    sda_input.nrun = num_b_surface_trajectories
    sda_input.solutes = model.sda_settings.solutes
    sda_input.total_grids = len(sda_input.solutes)

    if model.sda_settings.geom_type is not None:
        sda_input.geom_type = model.sda_settings.geom_type

    total_solutes = 0
    for solute in model.sda_settings.solutes:
        total_solutes += solute.solute_grid.nb_solute
    sda_input.total_solutes = total_solutes
    if total_solutes > 2:
        sda_input.type = "sdamm"
    sda_input.solutes_path = bd_directory

    sda_input.write(os.path.join(bd_directory, SDA_INPUT))

    
    return

def make_add_atoms(model, rootdir, bd_directory=None):

    """
    Creates add_atoms input file, which contains specific parameters
    for special atoms such as halogen's VdW or NTR and CTR's test charges
    
    Parameters
    ----------
    model : Model()
        The SEEKR2 model.

    rootdir : str
        The model's root directory.
        
    bd_directory : str
        Directory where the add_atoms file will be written.
    """

    if bd_directory is None:
        # B-surface
        bd_directory = os.path.join(
            rootdir, model.k_on_info.b_surface_directory)
    else:
        # BD Milestone
        bd_directory = os.path.join(rootdir, bd_directory)

    add_atoms_filename = os.path.join(bd_directory, "add_atoms")

    vdws = []
    test_charges = []
    
    for atom in model.sda_settings.atoms:
        if atom.resname is None:
            atom.resname = "*"
        if atom.vdw is not None:
            string = "{:5s}{:>3s} {:>6.2f}\n".format(atom.type, atom.resname, atom.vdw)
            vdws.append(string)
        if atom.test_charge is not None:
            string = "{:5s}{:>3s} {:>6.2f}\n".format(atom.type, atom.resname, atom.test_charge)
            test_charges.append(string)

    with open(add_atoms_filename, "w") as add_atoms:
        
        add_atoms.write("GROUP = VdW\n")
        for vdw in vdws:
            add_atoms.write(vdw)
        add_atoms.write("END GROUP\n")

        add_atoms.write("\n")

        add_atoms.write("GROUP = TestCharges\n")
        for test_charge in test_charges:
            add_atoms.write(test_charge)    
        add_atoms.write("END GROUP\n")

def run_hydropro(model, rootdir, hydropro_dir, bd_directory=None):

    """
    Creates hydropro's input files and run hydropro to calculate
    translational and diffussional coefficients of the solutes

    Parameters
    ----------
    model : Model()
        The SEEKR2 model.

    rootdir : str
        The model's root directory.
           
    hydropro_dir : str
        Directory where hydropro program is stored.

    bd_directory : str
        The b_surface directory where the SDA input file 
        is located.
    """

    if bd_directory is None:
        # B-surface
        bd_directory = os.path.join(
            rootdir, model.k_on_info.b_surface_directory)
    else:
        # BD Milestone
        bd_directory = os.path.join(rootdir, bd_directory)

    print("Calculating diffusion coefficients")

    hydropro = sim_sda.Hydropro()

    current_dir = os.getcwd()
    os.chdir(bd_directory)

    for solute in model.sda_settings.solutes:

        solute_name = solute.pqr_filename.split(".")[:-1]
        solute_name = ".".join(solute_name)
        solute_pdbfile = solute_name+"_noh.pdb"

        hydropro.temperature = model.temperature
        hydropro.pdbfile = solute_pdbfile

        hydropro_filename = "hydropro.dat"

        #print(solute.solute_grid.surface.lower())
        #exit()

        if solute.solute_grid.surface.lower() == "yes":
            solute.solute_grid.trans_diffusion = 0.000
            solute.solute_grid.rot_diffusion = 0.000
        
        else:
            if solute.type.lower() == "non_protein":
                hydropro.write_input(hydropro_filename, small=True)
            else:
                hydropro.write_input(hydropro_filename, small=False)

            hydropro_bin = os.path.join(hydropro_dir, "hydropro10-lnx.exe")
            hydropro_command = hydropro_bin + " " + hydropro_filename + " " + \
                solute_pdbfile + " > " + \
                solute_name+"_noh-hydropro.out"

            #print("Ignore the forrtl error")
            os.system(hydropro_command)

            #output_file = solute_name + "_noh-res.txt"
            for root, dirs, files in os.walk("."):
                for filename in files:
                    if solute_name in filename and "res.txt" in filename:
                        output_file = filename

            trans_diffusion, rot_diffusion = hydropro.read_output(output_file)

            solute.solute_grid.trans_diffusion = trans_diffusion
            solute.solute_grid.rot_diffusion = rot_diffusion
    
    os.chdir(current_dir)

    return

def modify_variables(bd_milestone_directory, bd_output_glob, 
                     n_trajectories, seed=None, 
                     output_file=None, restart=False):
    """
    Modify several variables within the sda*.out file at 
    runtime based on user inputs.
    
    Parameters
    ----------
    bd_milestone_directory : str
        The path to the directory holding the simulation XML.
        
    bd_output_glob : str
        A glob used to detect the presence of existing BD results
        files. If they are not detected, restart mode may not be used.
        
    n_trajectories : None or int
        The parameter <n_trajectories> represents the total number of
        individual BD trajectories that will be run per invocation of
        the 'nam_simulation' program. If left at None, then the 
        existing value of <n_trajectories> will be left alone in the 
        simulation file. Otherwise, if changed to an integer, the 
        value for <n_trajectories> will be modified in the simulation
        file.
        
    seed : None or int
        The parameter <seed> represents the random number seed which 
        will be used in BD. If left at None, then the 
        existing value of <seed> will be left alone in the 
        simulation file. Otherwise, if changed to an integer, the 
        value for <seed> will be modified in the simulation
        file.
        
    restart : bool
        Whether or not this file is being modified for a restart 
        simulation. If set to True, the 'seed' will be automatically
        incremented to generate randomness.
    """
    simulation_filename_base = SDA_INPUT
    simulation_filename = os.path.join(bd_milestone_directory, 
                                       simulation_filename_base)
    sim_file_old_lines = []
    sim_file_new_lines = []
    with open(simulation_filename, 'r') as f:
        for line in f.readlines():
            sim_file_old_lines.append(line)
            
    results_file_glob = os.path.join(bd_milestone_directory, bd_output_glob)
    results_file_list = glob.glob(results_file_glob)
    if restart:
        assert len(results_file_list) > 0, \
            "No simulation has yet been run: cannot use restart mode."
        restart_index = len(results_file_list) + 1
        if seed is None:
            seed = restart_index
        else:
            seed += restart_index
    else:
        restart_index = 1
        cleanse_bd_outputs(bd_milestone_directory, check_mode=False)
        
    trajectory_file = "traj_%d" % restart_index
    complexes_file = "complexes_%d" % restart_index
    
    if output_file is None:
        output_file = "sda_%d.out" % restart_index
    
    for line in sim_file_old_lines:
        new_line = line
        if n_trajectories is not None:
            new_line = re.sub(r"(?is)nrun.+", 
                   "nrun =  %d\n" % n_trajectories, 
                   new_line)
            
        if seed is not None:
            new_line = re.sub(r"(?is)dseed.+", 
                   "dseed = %d\n" % seed, new_line)
            
        new_line = re.sub(r"(?is)ftrajectories.+", 
            "ftrajectories = %s\n" % trajectory_file, 
            new_line)
        
        new_line = re.sub(r"(?is)fcomplexes.+", 
            "fcomplexes = %s\n" % complexes_file, 
            new_line)
            
        sim_file_new_lines.append(new_line)
    
    with open(output_file, 'w') as f:
        for line in sim_file_new_lines:
            f.write(line)
            
    return

def run_nam_simulation(sda_bin_dir, bd_directory, sda_output_glob, 
                       force_overwrite=False):
    """
    Run the SDA simulation.
    
    Parameters
    ----------
    sda_bin_dir : str
        The location of all the SDA binaries (programs). If the
        binaries have been added to the system PATH environmental
        variable, then this can be an empty string: "".
        
    bd_directory : str
        The path to the directory where SDA simulations will be run.
        
    sda_output_glob : str
        A glob to detect the presence of results files to ensure that
        simulations ran properly.
    """

    curdir = os.getcwd()
    print("moving to directory:", bd_directory)
    os.chdir(bd_directory)
    bd_command = os.path.join(sda_bin_dir, "sda_flex")
    simulation_filename = SDA_INPUT
    command = bd_command + " " + simulation_filename + \
    " > sda.out"

    if force_overwrite:
        print("running command:", command)
        os.system(command)
    else:
        if not os.path.exists("sda.out"):
            print("running command:", command)
            os.system(command)
        else:
            pattern = "INFO All your SDA runs/trajectories finished successfully."
            ran = False
            with open('your_file.txt', 'r') as file:
                for line in file:
                    if re.search(pattern, line):  # Check if pattern is in the line
                        ran = True
                        break
            if not ran:
                print("running command:", command)
                os.system(command)
            else:
                print("SDA simulations already ran.")
                print("If you want to run them again, set force_overwrite.")

    results_glob = glob.glob(sda_output_glob)
    assert len(results_glob) > 0, "Problem occurred running "\
        "nam_simulation: results file was not generated."
    os.chdir(curdir)
    return

if __name__ == "__main__":
    argparser = argparse.ArgumentParser(description=__doc__)
    argparser.add_argument(
        "bd_milestone", metavar="BD_MILESTONE", type=str, 
        help="Which milestone to run SDA for. Arguments may be the "\
        "string 'b_surface' or a numerical index of a given BD_milestone.")
    argparser.add_argument(
        "model_file", metavar="MODEL_FILE", type=str, 
        help="name of model file for OpenMMVT calculation. This would be the "\
        "XML file generated in the prepare stage.")
    argparser.add_argument(
        "-r", "--restart", dest="restart", default=False,
        help="Restart simulations to obtain more results.", action="store_true")
    argparser.add_argument("-n", "--n_trajectories", dest="n_trajectories", 
        default=None, help="Enter a different number of trajectories to run "\
        "the simulation if a different number of trajectories are desired "\
        "than what is in the input.xml file.", type=int)
    argparser.add_argument("-t", "--n_threads", dest="n_threads", 
        default=None, help="Enter a different number of threads to run "\
        "the simulation if a different number of threads are desired "\
        "than what is in the input.xml file.", type=int)
    argparser.add_argument("-o", "--output_file", dest="output_file",
        default=None, help="Enter a new output file name different from the "\
        "output file specified in the input.xml file.", type=str)
    argparser.add_argument("-s", "--seed", dest="seed", default=None, 
        help="Enter a new random number seed if different from the "\
        "seed specified in the input.xml file.", type=int)
    argparser.add_argument("-d", "--directory", dest="directory",
        default=None, help="Provide the location of the directory which "\
        "contains the anchors. If this argument is omitted, then the "\
        "directory within the anchor_rootdir setting of the INPUT_FILE will "\
        "be used.", type=str)
    argparser.add_argument("-f", "--force_overwrite", dest="force_overwrite",
        default=False, help="Toggle whether to overwrite existing files "\
        "within milestone. If this option is enabled, "\
        "then the anchor's production directory will be emptied of all "\
        "output, trajectory, and results files for the new simulation.", 
        action="store_true")
        
    args = argparser.parse_args() # parse the args into a dictionary
    args = vars(args)
    bd_milestone_index = args["bd_milestone"]
    model_file = args["model_file"]
    restart = args["restart"]
    n_trajectories = args["n_trajectories"]
    n_threads = args["n_threads"]
    output_file = args["output_file"]
    seed = args["seed"]
    directory = args["directory"]
    force_overwrite = args["force_overwrite"]
    
    b_surface = True
    if bd_milestone_index.lower() == "b_surface":
        bd_milestone_index = bd_milestone_index.lower()
        b_surface = True
    else:
        print("At this time, the only allowed bd_milestone argument must be "\
              "the string 'b_surface'.")
        exit()
    
    model = base.load_model(model_file, directory)
        
            
    assert os.path.exists(model.anchor_rootdir), "An incorrect directory "\
        "was provided."
    
    if b_surface:
        bd_milestone_directory = os.path.join(
            model.anchor_rootdir, model.k_on_info.b_surface_directory)
    else:
        raise Exception("b_surface is the only option allowed at this time.")
        
    bd_directory_list = [bd_milestone_directory]
        
    for bd_directory in bd_directory_list:
        make_sda_grids(model.sda_settings.sda_bin_dir, 
                   bd_directory, restart, force_overwrite)
        assert n_trajectories is not None, "The argument '--n_trajectories' "\
            "(-n) must be set for the specified calculation."
        modify_variables(bd_directory, model.k_on_info.bd_output_glob, 
                         n_trajectories, seed, restart)
        run_nam_simulation(model.sda_settings.sda_bin_dir, 
                           bd_directory, 
                           model.k_on_info.bd_output_glob)