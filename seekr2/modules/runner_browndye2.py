"""
runner_browndye.py

A command-line tool for running SEEKR calculations using the BrownDye
engine either locally or on a computing resource.
"""
import os
import re
import argparse
import glob

import seekr2.modules.common_base as base
import seekr2.modules.common_sim_browndye2 as sim_browndye2

REACTION_FILENAME = "rxns.xml"
DEFAULT_N_TRAJ_PER_OUT = 1000

def make_empty_pqrxml(directory, filename="empty.pqrxml"):
    """
    Create an empty pqrxml which is used in the Extraction phase to 
    generate new ligand encounter complex PQRs.
    
    Returns
    -------
    empty_pqrxml_path: str
        Generated path of empty pqrxml file.
    """
    
    empty_pqrxml_path = os.path.join(directory, filename)
    with open(empty_pqrxml_path, "w") as f:
        empty_pqrxml_string = "<roottag> \n</roottag>"
        f.write(empty_pqrxml_string)
    return empty_pqrxml_path

def cleanse_bd_outputs(directory, check_mode=True):
    """
    Check for simulation outputs in an existing directory, optionally
    delete them to make way for new outputs. If 'check_mode' is
    False, then files won't be deleted, but their existence will be
    reported.
    
    Parameters
    ----------
    directory : str
        The path to the directory where the BD files will be 'cleansed'.
    
    check_mode : bool, default True
        If set to True, then files will be detected, but not removed.
        If set to False, then files will be both detected and removed.
        
    Returns
    -------
    files_will_be_removed : bool
        If files generated by a BD preparation or simulation were 
        present, will return True, will return False otherwise.
    """
    files_will_be_removed = False
    output_files_glob = os.path.join(directory, base.BROWNDYE_OUTPUT)
    output_files_list = glob.glob(output_files_glob)
    for output_file in output_files_list:
        files_will_be_removed = True
        if not check_mode:
            os.remove(output_file)
    
    simulation_file_glob = os.path.join(directory, "*_simulation.xml")
    for simulation_file in glob.glob(simulation_file_glob):
        files_will_be_removed = True
        if not check_mode:
            os.remove(simulation_file)
    
    traj_file_glob = os.path.join(directory, "traj*.xml")
    for traj_file in glob.glob(traj_file_glob):
        files_will_be_removed = True
        if not check_mode:
            os.remove(traj_file)
    return files_will_be_removed

def make_browndye_input_xml(model, rootdir, receptor_xml_filename, 
                            ligand_xml_filename, num_bd_steps, 
                            bd_directory=None, make_apbs_mode=True):
    """
    Creates Browndye input file with all input parameters set.
    If bd_directory is None, then b_surface is assumed.
    
    Parameters
    ----------
    model : Model()
        The SEEKR2 model.
        
    rootdir : str
        The model's root directory.
           
    receptor_xml_filename : str
        receptor PQRXML structure.
    
    ligand_xml_filename : str
        ligand PQRXML structure.
    
    num_bd_steps : int
        The number of BD steps to run
    
    bd_directory : str
        Browndye directory
    
    make_apbs_mode : bool
        Whether to use Browndye2's automatic APBS grid generator.
    
    Returns
    -------
    debye_length : float
        The Debye length of the system based on calculation by APBS.
        
    reaction_filename : str
        A path to the reaction file.
    """
    
    root = sim_browndye2.Root()
    if bd_directory is None:
        # B-surface
        bd_directory = os.path.join(
            rootdir, model.k_on_info.b_surface_directory)
        root.system.start_at_site = "False"
    else:
        # BD Milestone
        bd_directory = os.path.join(rootdir, bd_directory)
        root.system.start_at_site = "True"
        
    root.n_trajectories = num_bd_steps
    if root.n_trajectories_per_output > root.n_trajectories:
        root.n_trajectories_per_output = root.n_trajectories
    root.n_threads = model.browndye_settings.n_threads
    root.system.reaction_file = REACTION_FILENAME
    reaction_filename = root.system.reaction_file
    if make_apbs_mode:
        root.system.solvent.debye_length = "-1.0"
        input_xml_filename = os.path.join(bd_directory, "apbs_input.xml")
    else:
        root.system.solvent.debye_length = model.browndye_settings.debye_length
        assert float(root.system.solvent.debye_length) > 0.0, \
            "The Debye length must be set if make_apbs_mode=False"
        input_xml_filename = os.path.join(bd_directory, "input.xml")
        
    root.system.solvent.kT = model.temperature / 298.0
    root.system.time_step_tolerances.minimum_core_dt = 0.2
    root.system.time_step_tolerances.minimum_core_reaction_dt = 0.05
    
    root.system.solvent.ions = []
    for model_ion in model.k_on_info.ions:
        bd_ion = sim_browndye2.Ion()
        bd_ion.radius = model_ion.radius
        bd_ion.charge = model_ion.charge
        bd_ion.conc = model_ion.conc
        root.system.solvent.ions.append(bd_ion)
        
    receptor_group = sim_browndye2.Group()
    receptor_group.name = sim_browndye2.BROWNDYE_RECEPTOR
    receptor_core = sim_browndye2.Core()
    receptor_core.name = sim_browndye2.BROWNDYE_RECEPTOR
    receptor_pqrxml_filename = os.path.basename(receptor_xml_filename)
    receptor_core.atoms = receptor_pqrxml_filename
    receptor_core.grid_spacing = model.browndye_settings.apbs_grid_spacing
    receptor_group.core_list.append(receptor_core)
    ligand_group = sim_browndye2.Group()
    ligand_group.name = sim_browndye2.BROWNDYE_LIGAND
    ligand_core = sim_browndye2.Core()
    ligand_core.name = sim_browndye2.BROWNDYE_LIGAND
    ligand_pqrxml_filename = os.path.basename(ligand_xml_filename)
    ligand_core.atoms = ligand_pqrxml_filename
    ligand_core.grid_spacing = model.browndye_settings.apbs_grid_spacing
    ligand_group.core_list.append(ligand_core)
    root.system.group_list.append(receptor_group)
    root.system.group_list.append(ligand_group)
    if make_apbs_mode:
        root.write(input_xml_filename)
        debye_length = sim_browndye2.make_and_run_apbs(
            root, input_xml_filename, 
            browndye2_bin=model.browndye_settings.browndye_bin_dir,
            new_input_xml_base=sim_browndye2.BROWNDYE_INPUT_FILENAME)
    else:
        root.write(input_xml_filename)
        debye_length = model.browndye_settings.debye_length
                
    return debye_length, reaction_filename
    
def make_browndye_reaction_xml(model, abs_reaction_path):
    """
    Creates Browndye2 reaction file.
    
    Parameters
    ----------
    model : Model()
        The model object contains all information needed for a SEEKR2
        calculation.
        
    abs_reaction_path : str
        The absolute path to where the reaction file will be written.
        
    bd_milestone : None or BD_milestone(), default None
        If None, then it is assumed that this reaction file is being 
        made for a b_surface calculation. Otherwise, the BD_milestone
        object being passed will define which BD milestone this 
        reaction file is being made for.
    """
    rxnroot = sim_browndye2.Reaction_root()
    rxnroot.first_state = "b_surface"
    ghost_indices_rec = model.browndye_settings.ghost_indices_rec
    ghost_indices_lig = model.browndye_settings.ghost_indices_lig
    
    for i, bd_milestone2 in enumerate(model.k_on_info.bd_milestones):
        ghost_index_rec = ghost_indices_rec[i] # comes from the model?
        ghost_index_lig = ghost_indices_lig[i]
        rxn_outer = sim_browndye2.Reaction()
        pair1 = sim_browndye2.Pair()
        from_state = "b"
        to_state = str(bd_milestone2.outer_milestone.index)
        rxn_outer.name = "{}_{}".format(from_state, to_state)
        rxn_outer.state_after = str(bd_milestone2.outer_milestone.index)
        pair1.distance = bd_milestone2.outer_milestone.variables['radius'] * 10.0
        rxn_outer.state_before = rxnroot.first_state
        rxn_outer.molecule0_group = sim_browndye2.BROWNDYE_RECEPTOR
        rxn_outer.molecule0_core = sim_browndye2.BROWNDYE_RECEPTOR
        rxn_outer.molecule1_group = sim_browndye2.BROWNDYE_LIGAND
        rxn_outer.molecule1_core = sim_browndye2.BROWNDYE_LIGAND
        rxn_outer.n_needed = 1
        pair1.atom1_index = ghost_index_rec
        pair1.atom2_index = ghost_index_lig
        rxn_outer.pair_list.append(pair1)
        rxnroot.reaction_list.append(rxn_outer)
        
        rxn_inner = sim_browndye2.Reaction()
        pair2 = sim_browndye2.Pair()
        from_state = str(bd_milestone2.outer_milestone.index)
        to_state = str(bd_milestone2.inner_milestone.index)
        rxn_inner.name = "{}_{}".format(from_state, to_state)
        rxn_inner.state_after = str(bd_milestone2.inner_milestone.index)
        pair2.distance = bd_milestone2.inner_milestone.variables['radius'] * 10.0
        rxn_inner.state_before = str(bd_milestone2.outer_milestone.index)
        rxn_inner.molecule0_group = sim_browndye2.BROWNDYE_RECEPTOR
        rxn_inner.molecule0_core = sim_browndye2.BROWNDYE_RECEPTOR
        rxn_inner.molecule1_group = sim_browndye2.BROWNDYE_LIGAND
        rxn_inner.molecule1_core = sim_browndye2.BROWNDYE_LIGAND
        rxn_inner.n_needed = 1
        pair2.atom1_index = ghost_index_rec
        pair2.atom2_index = ghost_index_lig
        rxn_inner.pair_list.append(pair2)
        rxnroot.reaction_list.append(rxn_inner)
        
        for j, bd_milestone3 in enumerate(model.k_on_info.bd_milestones):
            if bd_milestone2.index == bd_milestone3.index:
                continue
            rxn_other = sim_browndye2.Reaction()
            pair3 = sim_browndye2.Pair()
            from_state = str(bd_milestone2.outer_milestone.index)
            to_state = str(bd_milestone3.outer_milestone.index)
            rxn_other.name = "{}_{}".format(from_state, to_state)
            rxn_other.state_after = str(bd_milestone3.outer_milestone.index)
            pair3.distance = bd_milestone3.outer_milestone.variables['radius'] * 10.0
            rxn_other.state_before = str(bd_milestone2.outer_milestone.index)
            rxn_other.molecule0_group = sim_browndye2.BROWNDYE_RECEPTOR
            rxn_other.molecule0_core = sim_browndye2.BROWNDYE_RECEPTOR
            rxn_other.molecule1_group = sim_browndye2.BROWNDYE_LIGAND
            rxn_other.molecule1_core = sim_browndye2.BROWNDYE_LIGAND
            rxn_other.n_needed = 1
            other_ghost_index_rec = ghost_indices_rec[j] # comes from the model?
            other_ghost_index_lig = ghost_indices_lig[j]
            pair3.atom1_index = other_ghost_index_rec
            pair3.atom2_index = other_ghost_index_lig
            rxn_other.pair_list.append(pair3)
            rxnroot.reaction_list.append(rxn_other)
        
    rxnroot.write(abs_reaction_path)
    return

def run_bd_top(browndye_bin_dir, bd_directory, restart=False,
               force_overwrite=False):
    """
    Prepare Browndye2 input files for simulation.
    
    Parameters
    ----------
    browndye_bin_dir : str
        The location of all the Browndye2 binaries (programs). If the
        binaries have been added to the system PATH environmental
        variable, then this can be an empty string: "".
        
    bd_directory : str
        The path to the directory where bd_top will be run.
        
    restart : bool, default False
        Whether this bd_top is being run for a restart simulation. If
        not, then an exception will be raised if previous simulation
        files already exist.
        
    force_overwrite : bool, default False
        If this is not a restart, and simulation files already exist
        in this directory, an exception will be raised unless this
        parameter is set to True. If set to True, any previously
        existing BD-related files may and will be overwritten.
    """
    curdir = os.getcwd()
    print("moving to directory:", bd_directory)
    os.chdir(bd_directory)
    simulation_filename = sim_browndye2.BROWNDYE_RECEPTOR + "_" \
        + sim_browndye2.BROWNDYE_LIGAND + "_simulation.xml"
    if os.path.exists(simulation_filename) and not restart:
        if force_overwrite:
            print("force_overwrite set to True: existing files will be "\
                  "overwritten.")
            os.remove(simulation_filename)
        else:
            print("This anchor already has existing output files and the "\
                  "entered command would overwrite them. If you desire to "\
                  "overwrite the existing files, then use the "\
                  "--force_overwrite (-f) option, and all outputs will be "\
                  "deleted and replaced by a new run.")
            raise Exception("Cannot overwrite existing Browndye outputs.")
        
    bd_command = os.path.join(browndye_bin_dir, "bd_top")
    command = bd_command + " " + sim_browndye2.BROWNDYE_INPUT_FILENAME
    assert os.path.exists(sim_browndye2.BROWNDYE_INPUT_FILENAME), \
        "Necessary file doesn't exist: %s" % \
        sim_browndye2.BROWNDYE_INPUT_FILENAME
    print("running command:", command)
    os.system(command)
    assert os.path.exists(simulation_filename), "Problem occurred running "\
        "bd_top: simulation file %s was not generated." % simulation_filename
    os.chdir(curdir)
    return

def modify_variables(bd_milestone_directory, bd_output_glob, 
                     n_trajectories, n_threads=None, seed=None, 
                     output_file=None, restart=False, 
                     n_trajectories_per_output=None):
    """
    Modify several variables within the *_simulation.xml file at 
    runtime based on user inputs.
    
    Parameters
    ----------
    bd_milestone_directory : str
        The path to the directory holding the simulation XML.
        
    bd_output_glob : str
        A glob used to detect the presence of existing BD results
        files. If they are not detected, restart mode may not be used.
        
    n_trajectories : None or int
        The parameter <n_trajectories> represents the total number of
        individual BD trajectories that will be run per invocation of
        the 'nam_simulation' program. If left at None, then the 
        existing value of <n_trajectories> will be left alone in the 
        simulation file. Otherwise, if changed to an integer, the 
        value for <n_trajectories> will be modified in the simulation
        file.
        
    n_threads : None or int
        The parameter <n_threads> represents the number of CPU cores 
        that will be requested during BD. If left at None, then the 
        existing value of <n_threads> will be left alone in the 
        simulation file. Otherwise, if changed to an integer, the 
        value for <n_threads> will be modified in the simulation
        file.
        
    seed : None or int
        The parameter <seed> represents the random number seed which 
        will be used in BD. If left at None, then the 
        existing value of <seed> will be left alone in the 
        simulation file. Otherwise, if changed to an integer, the 
        value for <seed> will be modified in the simulation
        file.
        
    output_file : None or str
        If left at None, then the existing name of the results file 
        will be left alone in the simulation file. Otherwise, if 
        changed to a string, the results file will be given that
        string as its name.
        
    restart : bool
        Whether or not this file is being modified for a restart 
        simulation. If set to True, the 'seed' will be automatically
        incremented to generate randomness.
        
    n_trajectories_per_output : None or int
        The parameter <n_trajectories_per_output> represents how 
        many trajectories must elapse before the results filename is
        updated. This parameter must be less than or equal to 
        <n_trajectories>. If left at None, then the existing value of 
        <n_trajectories_per_output> will be left alone in the 
        simulation file. Otherwise, if changed to an integer, the 
        value for <n_trajectories_per_output> will be modified in the 
        simulation file.
    """
    simulation_filename_base = sim_browndye2.BROWNDYE_RECEPTOR + "_" \
        + sim_browndye2.BROWNDYE_LIGAND + "_simulation.xml"
    simulation_filename = os.path.join(bd_milestone_directory, 
                                       simulation_filename_base)
    sim_file_old_lines = []
    sim_file_new_lines = []
    with open(simulation_filename, 'r') as f:
        for line in f.readlines():
            sim_file_old_lines.append(line)
            
    results_file_glob = os.path.join(bd_milestone_directory, bd_output_glob)
    results_file_list = glob.glob(results_file_glob)
    if restart:
        assert len(results_file_list) > 0, \
            "No simulation has yet been run: cannot use restart mode."
        restart_index = len(results_file_list) + 1
        if seed is None:
            seed = restart
        else:
            seed += restart
    else:
        restart_index = 1
        cleanse_bd_outputs(bd_milestone_directory, check_mode=False)
        
    trajectory_file = "traj%d_" % restart_index
    
    if output_file is None:
        output_file = "results%d.xml" % restart_index
    
    for line in sim_file_old_lines:
        new_line = line
        if n_trajectories is not None:
            new_line = re.sub(r"(?is)<n_trajectories>.+</n_trajectories>", 
                   "<n_trajectories> %d </n_trajectories>" % n_trajectories, 
                   new_line)
        
            if n_trajectories_per_output is None:
                n_trajectories_per_output = n_trajectories
            
            new_line = re.sub(r"(?is)<n_trajectories_per_output>.+"\
                              "</n_trajectories_per_output>", 
                   "<n_trajectories_per_output> %d "\
                   "</n_trajectories_per_output>" % n_trajectories_per_output, 
                   new_line)
        
        if n_threads is not None:
            new_line = re.sub(r"(?is)<n_threads>.+</n_threads>", 
                   "<n_threads> %d </n_threads>" % n_threads, new_line)
            
        if seed is not None:
            new_line = re.sub(r"(?is)<seed>.+</seed>", 
                   "<seed> %d </seed>" % seed, new_line)
            
        if output_file is not None:
            new_line = re.sub(r"(?is)<output>.+</output>", 
                   "<output> %s </output>" % output_file, new_line)
            
        new_line = re.sub(r"(?is)<trajectory_file>.+</trajectory_file>", 
            "<trajectory_file> %s </trajectory_file>" % trajectory_file, 
            new_line)
            
        sim_file_new_lines.append(new_line)
    
    with open(simulation_filename, 'w') as f:
        for line in sim_file_new_lines:
            f.write(line)
            
    return

def run_nam_simulation(browndye_bin_dir, bd_directory, bd_output_glob):
    """
    Run the Browndye2 simulation.
    
    Parameters
    ----------
    browndye_bin_dir : str
        The location of all the Browndye2 binaries (programs). If the
        binaries have been added to the system PATH environmental
        variable, then this can be an empty string: "".
        
    bd_directory : str
        The path to the directory where bd_top will be run.
        
    bd_output_glob : str
        A glob to detect the presence of results files to ensure that
        simulations ran properly.
    """
    curdir = os.getcwd()
    print("moving to directory:", bd_directory)
    os.chdir(bd_directory)
    bd_command = os.path.join(browndye_bin_dir, "nam_simulation")
    simulation_filename = sim_browndye2.BROWNDYE_RECEPTOR + "_" \
        + sim_browndye2.BROWNDYE_LIGAND + "_simulation.xml"
    command = bd_command + " " + simulation_filename
    print("running command:", command)
    os.system(command)
    results_glob = glob.glob(bd_output_glob)
    assert len(results_glob) > 0, "Problem occurred running "\
        "nam_simulation: results file was not generated."
    os.chdir(curdir)
    return

if __name__ == "__main__":
    argparser = argparse.ArgumentParser(description=__doc__)
    argparser.add_argument(
        "bd_milestone", metavar="BD_MILESTONE", type=str, 
        help="Which milestone to run BrownDye for. Arguments may be the "\
        "string 'b_surface' or a numerical index of a given BD_milestone.")
    argparser.add_argument(
        "model_file", metavar="MODEL_FILE", type=str, 
        help="name of model file for OpenMMVT calculation. This would be the "\
        "XML file generated in the prepare stage.")
    argparser.add_argument(
        "-r", "--restart", dest="restart", default=False,
        help="Restart simulations to obtain more results.", action="store_true")
    argparser.add_argument("-n", "--n_trajectories", dest="n_trajectories", 
        default=None, help="Enter a different number of trajectories to run "\
        "the simulation if a different number of trajectories are desired "\
        "than what is in the input.xml file.", type=int)
    argparser.add_argument("-t", "--n_threads", dest="n_threads", 
        default=None, help="Enter a different number of threads to run "\
        "the simulation if a different number of threads are desired "\
        "than what is in the input.xml file.", type=int)
    argparser.add_argument("-o", "--output_file", dest="output_file",
        default=None, help="Enter a new output file name different from the "\
        "output file specified in the input.xml file.", type=str)
    argparser.add_argument("-s", "--seed", dest="seed", default=None, 
        help="Enter a new random number seed if different from the "\
        "seed specified in the input.xml file.", type=int)
    argparser.add_argument("-d", "--directory", dest="directory",
        default=None, help="Provide the location of the directory which "\
        "contains the anchors. If this argument is omitted, then the "\
        "directory within the anchor_rootdir setting of the INPUT_FILE will "\
        "be used.", type=str)
    argparser.add_argument("-f", "--force_overwrite", dest="force_overwrite",
        default=False, help="Toggle whether to overwrite existing files "\
        "within milestone. If this option is enabled, "\
        "then the anchor's production directory will be emptied of all "\
        "output, trajectory, and results files for the new simulation.", 
        action="store_true")
        
    args = argparser.parse_args() # parse the args into a dictionary
    args = vars(args)
    bd_milestone_index = args["bd_milestone"]
    model_file = args["model_file"]
    restart = args["restart"]
    n_trajectories = args["n_trajectories"]
    n_threads = args["n_threads"]
    output_file = args["output_file"]
    seed = args["seed"]
    directory = args["directory"]
    force_overwrite = args["force_overwrite"]
    
    b_surface = True
    if bd_milestone_index.lower() == "b_surface":
        bd_milestone_index = bd_milestone_index.lower()
        b_surface = True
    else:
        print("At this time, the only allowed bd_milestone argument must be "\
              "the string 'b_surface'.")
        exit()
    
    model = base.load_model(model_file, directory)
        
    if n_threads is not None:
        model.browndye_settings.n_threads = n_threads
        
    assert os.path.exists(model.anchor_rootdir), "An incorrect directory "\
        "was provided."
    
    if b_surface:
        bd_milestone_directory = os.path.join(
            model.anchor_rootdir, model.k_on_info.b_surface_directory)
    else:
        raise Exception("b_surface is the only option allowed at this time.")
        
    bd_directory_list = [bd_milestone_directory]
        
    for bd_directory in bd_directory_list:
        run_bd_top(model.browndye_settings.browndye_bin_dir, 
                   bd_directory, restart, force_overwrite)
        n_trajectories_per_output = DEFAULT_N_TRAJ_PER_OUT
        assert n_trajectories is not None, "The argument '--n_trajectories' "\
            "(-n) must be set for the specified calculation."
        if n_trajectories_per_output > n_trajectories:
            n_trajectories_per_output = n_trajectories
        modify_variables(bd_directory, model.k_on_info.bd_output_glob, 
                         n_trajectories, n_threads, seed, output_file, restart,
                         n_trajectories_per_output=n_trajectories_per_output)
        run_nam_simulation(model.browndye_settings.browndye_bin_dir, 
                           bd_directory, 
                           model.k_on_info.bd_output_glob)
    